Projectverslag: Ontwikkeling van het 3D Blu-ray Authoring Script
Doelstelling: Het creëren van een Python-script dat een 3D Side-by-Side (SBS) videobestand kan omzetten naar een functionele, afspeelbare Blu-ray 3D ISO.

Fase 1: De Initiële Aanpak en de Kernfout
Onze eerste poging was logisch en direct: gebruik twee aparte, parallelle ffmpeg-processen om de linker- en rechterhelft van de video te encoderen naar twee losse .264 (H.264 elementary stream) bestanden. Deze bestanden zouden we vervolgens aan tsMuxeR geven om samen te voegen tot een 3D-structuur.

Resultaat: Mislukt. De resulterende ISO was corrupt en niet afspeelbaar.
Analyse: De logs van tsMuxeR onthulden een fundamenteel en schijnbaar onlogisch probleem: het rapporteerde een verschillend aantal frames voor de twee streams (bv. Processed 1970 video frames voor de ene en Processed 1971 video frames voor de andere).
Conclusie: Hoewel het onmogelijk leek om uit één bron twee streams met een verschillend aantal frames te halen, was dit het onweerlegbare bewijs van een incompatibiliteit. De oorzaak was niet dat ffmpeg een extra frame creëerde, maar dat de twee losse processen bestanden produceerden met minieme structurele verschillen (zoals de end-of-stream marker). tsMuxeR interpreteerde een van deze bestanden verkeerd en "zag" een "spookframe" dat er niet was.
Fase 2: Pogingen tot Synchronisatie
Om het "spookframe"-probleem op te lossen, hebben we verschillende strategieën geprobeerd om de output van ffmpeg te synchroniseren.

Eén ffmpeg-proces, Twee Outputs: We hebben de ffmpeg-opdracht herschreven om met een enkele, complexe filtergraph twee .264-bestanden tegelijk te genereren. De theorie was dat één proces zou zorgen voor perfect identieke bestanden.

Resultaat: Mislukt. Hoewel ffmpeg nu correct frame=1970 rapporteerde voor beide outputs, zag tsMuxeR nog steeds 1971 frames.
Conclusie: Dit bewees dat het probleem niet lag bij de synchronisatie binnen ffmpeg, maar fundamenteel bij hoe tsMuxeR de "ruwe" .264-streams leest die ffmpeg produceert.
Onderzoek naar tsMuxeR-vlaggen: Jouw onderzoek bracht aan het licht dat tsMuxeR standaard probeert om streams te "verbeteren" door SPS/PPS-headers in te voegen (insertSEI, contSPS).

Hypothese: Deze "verbeteringen" waren in conflict met de reeds Blu-ray-conforme streams die ffmpeg aanmaakte, wat de corruptie veroorzaakte.
Implementatie: We hebben de tsMuxeR-metafile aangepast om deze vlaggen te verwijderen. Dit was een cruciale stap voorwaarts, maar loste het onderliggende "spookframe"-probleem nog niet volledig op.
Fase 3: De "Gold Standard" Workflow (Huidige Implementatie)
De lessen uit de vorige fases leidden tot de huidige, robuuste en succesvolle workflow. Deze aanpak gebruikt de juiste tool voor elke specifieke taak en omzeilt de bewezen zwaktes van de afzonderlijke tools.

Stap 1: Encoderen naar een Gesynchroniseerde MKV-container.

Waarom: Dit is de enige methode die we hebben gevonden die ffmpeg in staat stelt om twee video-streams te produceren die gegarandeerd 100% frame-perfect gesynchroniseerd zijn. De MKV-container fungeert als een stabiele "doos" die de timing van beide streams perfect bewaart.
Implementatie: Het encoder.py-script is nu ontworpen om één enkele video_3d.mkv te produceren.
Stap 2: Extractie met de Specialist (mkvextract).

Waarom: We hebben bewezen dat ffmpeg's eigen stream-extractie (-c copy) onbetrouwbaar is en de timingproblemen kan herintroduceren. mkvextract (onderdeel van de MKVToolNix-suite) is de industriestandaard, speciaal ontworpen om streams bit-perfect en zonder timing-aanpassingen uit een MKV te halen.
Implementatie: Het muxer.py-script roept nu mkvextract aan om de twee perfecte streams uit de video_3d.mkv te halen en op te slaan als left_eye.264 en right_eye.264.
Stap 3: Muxen met tsMuxeR (met Minimale Inmenging).

Waarom: Nu tsMuxeR twee schone, perfect gesynchroniseerde streams ontvangt, en we de conflicterende insertSEI/contSPS-vlaggen hebben verwijderd, kan het zijn werk correct doen zonder de streams te beschadigen.
Implementatie: De muxer.py genereert een muxer_final.meta-bestand dat verwijst naar de door mkvextract gecreëerde .264-bestanden en roept tsMuxeR aan om de finale ISO te bouwen.
Setup en Dependencies
Vereiste Software: De finale workflow vereist ffmpeg, ffprobe, tsMuxeR (de moderne "justdan96"-fork) en de volledige MKVToolNix-suite (voor mkvextract).
Validatie: Het check_dependencies.py-script is geïmplementeerd om bij de start te verifiëren of al deze tools correct geïnstalleerd en vindbaar zijn in de systeem-PATH.
Versiebeheer: Het project is succesvol geïnitialiseerd als een Git-repository en gepusht naar GitHub, waardoor de code veilig is en toekomstige ontwikkeling wordt vergemakkelijkt.
Eindconclusie: De huidige staat van het script is het resultaat van een iteratief proces van trial-and-error en analyse. De "MKV-tussenstap"-workflow is niet een onnodige omweg, maar een bewuste en noodzakelijke architectuurkeuze om de bewezen zwaktes en incompatibiliteiten tussen ffmpeg en tsMuxeR te omzeilen. Dit is de meest stabiele en betrouwbare basis voor verdere ontwikkeling.
